<!DOCTYPE html>
<html>

  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>How to use WebSocket - Less Or More</title>

	<link rel="shortcut icon" href="/styles/images/favicon.jpg">
	<link rel="icon" href="/styles/images/favicon.jpg">

	<link rel="stylesheet" href="/styles/css/index.css">
	<link rel="stylesheet" href="/styles/css/fontawesome/css/font-awesome.min.css">
	<link rel="stylesheet" href="/styles/css/syntax.css">
	<link rel="canonical" href="/2018/07/09/use-websocket-com/">
	<link rel="alternate" type="application/rss+xml" title="Less Or More" href="/feed.xml">
	
	<meta name="keywords" content="How to use WebSocket, Less Or More, 康志华;个人博客;学而不思则罔;思而不学则殆;生命不止;折腾不休">
	<meta name="description" content="康志华;个人博客;学而不思则罔;思而不学则殆;生命不止;折腾不休">

	<script src="/styles/js/jquery.min.js"></script>
	<!--[if lt IE 9]>
    	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  	<![endif]-->
  	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?94be4b0f9fc5d94cc0d0415ea6761ae9";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
  	<style type="text/css">
	  	.docs-content{
	  		margin-bottom: 10px;
	  	}
  	</style>
</head>

  <body class="index">

    <header class="navbar navbar-inverse navbar-fixed-top docs-nav" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="/" class="navbar-brand">
        <img src="/styles/images/logo.jpg">
      </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">    
        <li>
          <a href="/">Home</a>
        </li>
        <li>
          <a href="/categories/">大类分解</a>
        </li>
        <li>
          <a href="/tag">小类内聚</a>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
            <a><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></a>
        </li>
        <li>
          <a href="/donate/"><strong>打赏</strong></a>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">关于<b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li><a rel="nofollow" target="_blank" href="https://github.com/luoyan35714/">Github</a></li>
            <li><a rel="nofollow" target="_blank" href="http://www.hifreud.com/Resume.io/">关于作者</a></li>
            <li><a rel="nofollow" href="/books">我的书单</a></li>
            <li><a rel="nofollow" href="http://www.hifreud.com/domains/">域名管理</a></li>
            <li><a rel="nofollow" href="/reference">推荐博客</a></li>
            <li><a href="/feed.xml">RSS订阅</a></li>
            <li class="divider"></li>
            <li><a rel="nofollow" target="_blank" href="https://github.com/luoyan35714/LessOrMore.git">本项目</a></li>
          </ul>
        </li>
      </ul>
    </nav>
  </div>
</header>
    <div class="docs-header" id="content">
  <div class="container">
  	
  		<!--
		    <h1>How to use WebSocket</h1>
		    <p>Post on Jul 09, 2018 by <a href="/about">wq</a></p>
		-->
		    <h1>It's our wits that make us men.</h1>
    
  </div>
</div>
    
      
<div class="banner">
  <div class="container">
  	
    	<a href="/categories/#WebSocket-ref">WebSocket</a>	/
    	<a href="/tag/#教程-ref">教程</a>
    
  </div>
</div>

    

    <div class="container docs-container">
  <div class="row">
    <div class="col-md-3">
      <div class="sidebar hidden-print" role="complementary">
        <div id="navigation">
  <h1>目录</h1>
  <ul class="nav sidenav">
  </ul>
  <div style="height: 200px;width: 200px;">
    <script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5ytn1ssq6za&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async"> 
    </script>
  </div>
</div>

 
      </div>
    </div>
    <div class="col-md-9" role="main">
      <div class="panel docs-content">
        <div class="wrapper">
            <header class="post-header">
              <h1 class="post-title">How to use WebSocket</h1>
              <!--
                <p class="post-meta">Jul 9, 2018</p>
              -->
              <div class="meta">Posted on <span class="postdate">Jul 09, 2018</span> By <a target="_blank" href="http://localhost:4000">wq</a></div>
              <br />
            </header>
            <article class="post-content">
              <ul id="markdown-toc">
  <li><a href="#1-为什么要使用websocket" id="markdown-toc-1-为什么要使用websocket">1、 为什么要使用websocket</a></li>
  <li><a href="#2-websocket-是如何进行工作的呢" id="markdown-toc-2-websocket-是如何进行工作的呢">2、 websocket 是如何进行工作的呢</a></li>
  <li><a href="#3-编写第一个demo" id="markdown-toc-3-编写第一个demo">3、 编写第一个Demo</a>    <ul>
      <li><a href="#a-热身" id="markdown-toc-a-热身">a 、热身</a></li>
      <li><a href="#b第一个demo" id="markdown-toc-b第一个demo">b、第一个demo</a></li>
    </ul>
  </li>
</ul>

<p>参考博客： <a href="https://blog.csdn.net/u014316363/article/details/43408325 ">https://blog.csdn.net/u014316363/article/details/43408325 </a></p>
<h2 id="1-为什么要使用websocket">1、 为什么要使用websocket</h2>
<p>传统的浏览器，是我们在浏览器端向服务器端请求数据，服务器端再将数据发送过来，随着对实时通信的需求，我们需要当服务器端的数据发生变化时，便将数据推送到浏览器端。这时我们想到的办法是建立长传机制，在服务器仍然有数据发送的时候，服务器与浏览器之间保持http连接，但是http连接的开销过大， 每次都需要发送http头和cookie数据 ，这无疑大大的加大了实际发送给服务器的数据量。为了解决这一问题，国际互联网工程任务组（The Internet Engineering Task Force，简称 IETF）设计了新的标准 也就是websocket，详见： <a href="http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html">JSR 356, Java API for WebSocket</a></p>
<h2 id="2-websocket-是如何进行工作的呢">2、 websocket 是如何进行工作的呢</h2>
<p>客户端建立websocket连接是通过 websocket握手过程建立的<br />
WebSocket握手过程</p>
<ol>
  <li>首先是由客户端发送常规的HTTP请求给服务器端，这个请求中包含了升级的头部，它告诉了服务器  希望建立websocket连接<br />
以下为请求建立连接的头部</li>
</ol>
<pre><code>
GET ws://websocket.example.com/ HTTP/1.1
Origin: http://example.com
Connection: Upgrade
Host: websocket.example.com
Upgrade: websocket
</code></pre>
<p>值得注意的是websocket使用的是  ws的方案，而wss是类似于 https一样的更为安全的方案</p>

<ol>
  <li>如果服务器支持websocket协议 并且同意与浏览器建立websocket连接   则响应该请求</li>
</ol>
<pre><code>	
	HTTP/1.1 101 WebSocket Protocol Handshake
	Date: Wed, 16 Oct 2013 10:07:34 GMT
	Connection: Upgrade
	Upgrade: WebSocket
</code></pre>
<p>这样就建立了像http一样的连接 并且可以进行发送数据  与http连接相似的是  他们都是建立在tcp/ip连接上</p>

<p>那怎么可以保证websocket传输的可靠性呢？<br />
为了保证这些信息可以正确的被重构，每一个帧都有4-12个字节的数据作为前缀，利用这种基于帧的数据传送，可以有效的减少无用数据的传送。<br />
如图：一个服务器可以连接好几个客户端  客户端可以用实现符合RFC 6455规范  与服务器端进行通信<br />
<img src="/styles/images/websocket/websocket_conmu.png" alt="websocket_commu" width="500" /></p>

<h2 id="3-编写第一个demo">3、 编写第一个Demo</h2>
<h4 id="a-热身">a 、热身</h4>
<p>（1）建立连接<br />
使用js建立连接</p>
<pre><code>var ws = 
			new WebSocket('ws://localhost:8080/websocketdemo02/websocket');</code></pre>
<p>可以将其放在button里面,手动点击建立连接即封装成一个函数，也可以放在js代码段的最前面，页面加载时便建立了连接。<br />
服务器端实现：</p>
<pre><code>@ServerEndpoint(value="/chat",encoders=MessageEncoder.class,decoders=MessageDecoder.class)
public class MyServer {
}</code></pre>
<p>可以通过ws://localhost:8080/项目名称/chat 与其建立连接<br />
若在其他主机上 则可以通过 IP地址进行连接   var ws=new WebSocket(‘ws://XXXX.XXXX.XXXX.XXXX/项目名称/chat’)<br />
（2）常用方法说明<br />
onOpen()  当连接建立成功后调用该函数；<br />
	服务器端:被@OnOpen()注解的函数<em>**</em></p>
<pre><code>@OnOpen
	public void onOpen(Session session) {
		System.out.println(String.format("%s jioned the chat room.",session.getId()));
		peers.add(session);
	}</code></pre>
<p>客户端：</p>
<pre><code>ws.onopen=function(event){

}</code></pre>
<p>需要注意的是  websocket是事件驱动的API   我们既可以采用注解，也可以采用接口驱动 这里我们采用接口驱动</p>

<p>onMessage()  当接收到信息时自动调用该函数；<br />
	服务器端：被@OnMessage注解的函数</p>
<pre><code>@OnMessage
	public void onMessage(String str,Session session) throws IOException,EncodeException, DecodeException{
		//broadcast the message  除了自己之外的别人都接受到消息
		System.out.println(str);
			for(Session peer:peers) {
			if(!session.getId().equals(peer.getId())) {
				peer.getBasicRemote().sendText(str);
			}
		}
	}</code></pre>
<p>static Set<Session> peers=Collections.synchronizedSet(new HashSet<Session>());可以记录所有的连接到该服务端的 session  
客户端 :</Session></Session></p>
<pre><code>//接收到消息的回调方法
	ws.onmessage=function(event){
		//alert("onmessage");//有消息发送过来时才调用该函数
		console.log(event.data);//
		var obj=JSON.parse(event.data);
		$("#ct").html(obj.message);
	}</code></pre>
<p>OnClose() 函数关闭时自动调用该函数；<br />
	服务器端：被 @OnClose注解的函数</p>
<pre><code>@OnClose
	public void OnClose(Session session) throws IOException,EncodeException{
		System.out.println(String.format("%s left the chat root.",session.getId()));
		peers.remove(session);
		
		for(Session peer:peers) {
			Message message=new Message();
			message.setSender("server");
			message.setContent(String.format("%s left the chat room",(String)session.getUserProperties().get("user")));
			message.setRecieved(new Date());
			peer.getBasicRemote().sendObject(message);
		}
	}</code></pre>

<p>客户端：</p>
<pre><code>/连接关闭的回调方法
      websocket.onclose = function () {
          setMessageInnerHTML("WebSocket连接关闭");
      }</code></pre>
<p>onError() 连接发生错误时调用该函数。<br />
服务器端：</p>
<pre><code>@OnError
	public void onError () {
	}</code></pre>
<p>客户端：</p>
<pre><code>ws.onerror=function(event){
		alert("erorr");
	}</code></pre>
<p>（3）发送消息<br />
在js中发送字符串</p>
<pre><code>exampleSocket.onopen = function (event) {
  exampleSocket.send("Here's some text that the server is urgently awaiting!"); 
};</code></pre>

<p>在js中通过websocket发送JSON格式的数据</p>
<pre><code>function sendText() {
  // Construct a msg object containing the data the server needs to process the message from the chat client.
  var msg = {
    type: "message",
    text: document.getElementById("text").value,
    id:   clientID,
    date: Date.now()
  };

  // Send the msg object as a JSON-formatted string.
  exampleSocket.send(JSON.stringify(msg));
  
  // Blank the text input element, ready to receive the next line of text from the user.
  document.getElementById("text").value = "";
}</code></pre>
<p>Js中对JSON格式的数据进行解析</p>
<pre><code>exampleSocket.onmessage = function(event) {
  var f = document.getElementById("chatbox").contentDocument;
  var text = "";
  var msg = JSON.parse(event.data);
  var time = new Date(msg.date);
  var timeStr = time.toLocaleTimeString();
  
  switch(msg.type) {
    case "id":
      clientID = msg.id;
      setUsername();
      break;
    case "username":
      text = "<b>User <em>" + msg.name + "</em> signed in at " + timeStr + "</b><br />";
      break;
    case "message":
      text = "(" + timeStr + ") <b>" + msg.name + "</b>: " + msg.text + "<br />";
      break;
    case "rejectusername":
      text = "<b>Your username has been set to <em>" + msg.name + "</em> because the name you chose is in use.</b><br />"
      break;
    case "userlist":
      var ul = "";
      for (i=0; i &lt; msg.users.length; i++) {
        ul += msg.users[i] + "<br />";
      }
      document.getElementById("userlistbox").innerHTML = ul;
      break;
  }
  
  if (text.length) {
    f.write(text);
    document.getElementById("chatbox").contentWindow.scrollByPages(1);
  }
};</code></pre>
<p>在java后台服务器端向客户端发送数据</p>
<pre><code>方法一：
@OnMessage
public String myOnMessage (String txt) {
   return txt.toUpperCase();
}
如果@OnMessage 注解的方法返回值不为空  返回的内容将会被发送


方法二：  
RemoteEndpoint.Basic other = session.getBasicRemote();
other.sendText ("Hello, world");

发送对象时   sendObject   ……..</code></pre>

<h4 id="b第一个demo">b、第一个demo</h4>
<p>第一个demo我们编写一个群聊系统我们需要实现的功能是  当一个客户端发送消息，其它的客户端都可以收到。</p>

<ul>
  <li>创建消息实体类</li>
  <li>消息转换为json类</li>
  <li>解析json为消息实体类</li>
  <li>服务器类</li>
  <li>客户端</li>
</ul>

<p>项目源码地址  <a href="https://github.com/WangQi1415/WebSocket/ ">https://github.com/WangQi1415/WebSocket/ </a></p>

            </article>
        </div>
      </div>
    </div>
  </div>
</div>

    
    <footer class="footer" role="contentinfo">
	<div class="container">
		<p class="copyright">Copyright &copy; 2014-2018 <a href="http://www.hifreud.com/Resume.io/"><code>wq</code></a>.</p>
		<p>Powered by <a href="http://jekyllrb.com">Jekyll</a>, themed from <a href="http://lesscss.cn/">Less</a>, refactored by <a href="http://www.hifreud.com/">Freud Kang</a></p>
	</div>
</footer>

<script src="/styles/js/jquery.min.js"></script>
<script src="/styles/js/bootstrap.min.js"></script>
<script src="/styles/js/holder.min.js"></script>
<script src="/styles/js/lessismore.js"></script>
<script src="/styles/js/application.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  </body>
</html>
